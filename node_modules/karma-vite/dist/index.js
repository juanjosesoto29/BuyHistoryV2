"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
const localPkg = require("local-pkg");
const connect = require("connect");
const vite = require("vite");
const IstanbulPlugin = require("vite-plugin-istanbul");
function stripHost(url) {
  return url.replace(/^https?:\/\/[a-z.:\d-]+\//, "/");
}
const queryRE = /\?.*$/s;
const hashRE = /#.*$/s;
const cleanUrl = (url) => url.replace(hashRE, "").replace(queryRE, "");
const getViteVersion = (root) => {
  var _a, _b;
  const version = ((_b = (_a = localPkg.getPackageInfoSync("vite", { paths: [root] })) == null ? void 0 : _a.version) == null ? void 0 : _b.split(".")[0]) || "4";
  return `vite${version}`;
};
const contextHtmlLikeSet = /* @__PURE__ */ new Set([
  "/context.html",
  "/debug.html",
  "/client_with_context.html"
]);
const beforeMiddlewareFactory = (vite2, config, logger) => {
  const { urlRoot } = config;
  const log = logger.create("karma-vite-beforeMiddleware");
  if (vite2 === void 0) {
    log.error("The config of framework field missing vite");
    throw "The config of framework field missing vite";
  }
  return (req, res, next) => {
    const url = req.url && stripHost(req.url);
    if (!(url == null ? void 0 : url.startsWith(urlRoot))) {
      return next();
    }
    const newUrl = url.replace(urlRoot, "/");
    if (contextHtmlLikeSet.has(newUrl)) {
      const originEnd = res.end.bind(res);
      res.end = (...args) => {
        if (typeof args[0] === "string") {
          const [html, ...rest] = args;
          void vite2.transformIndexHtml(`/__vite__${newUrl}`, html).then((data) => {
            originEnd(data, ...rest);
          });
        } else {
          originEnd(...args);
        }
        return res;
      };
    }
    next();
  };
};
beforeMiddlewareFactory.$inject = ["vite.value", "config", "logger"];
const frameworkFactory = (vite2, config) => {
  var _a;
  if (((_a = config.vite) == null ? void 0 : _a.autoInit) !== false) {
    config.set({
      beforeMiddleware: (config.beforeMiddleware || []).concat(["vite-before"]),
      middleware: (config.middleware || []).concat(["vite"])
    });
  }
  return vite2;
};
frameworkFactory.$inject = ["vite", "config"];
const VITE_CLIENT_ENTRY = require.resolve("karma-vite/dist/viteClientMock.js");
const VITE_FS_PREFIX = "/@fs/";
const REWRITE_URL_KEY = "__karma_vite_rewrite_url__";
const unwantedViteClientHtml = /* @__PURE__ */ new Set([
  "/",
  "/context.html",
  "/client_with_context.html"
]);
const adjustPrefixMiddleware = (urlRoot, base, log) => {
  return (req, res, next) => {
    const url = req.url && cleanUrl(stripHost(req.url));
    const basePrefix = `${urlRoot}base/`;
    const absolutePrefix = `${urlRoot}absolute/`;
    let originPrefix, targetPrefix;
    if (url == null ? void 0 : url.startsWith(basePrefix)) {
      originPrefix = basePrefix;
      targetPrefix = base;
    } else if (url == null ? void 0 : url.startsWith(absolutePrefix)) {
      originPrefix = absolutePrefix;
      targetPrefix = `${base.slice(0, -1)}${VITE_FS_PREFIX}`;
    }
    if (url && originPrefix && targetPrefix) {
      req.url = url.replace(originPrefix, targetPrefix);
      Reflect.defineProperty(req, REWRITE_URL_KEY, {
        value: [absolutePrefix, targetPrefix],
        enumerable: false
      });
      log.debug(`Url prefix rewritten: ${url} -> ${req.url}`);
    }
    next();
  };
};
const restorePrefixMiddleware = (log) => {
  return (req, res, next) => {
    const url = req.url && cleanUrl(stripHost(req.url));
    const rewriteValue = req[REWRITE_URL_KEY];
    if (url !== void 0 && rewriteValue) {
      const [originPrefix, targetPrefix] = rewriteValue;
      req.url = url.replace(originPrefix, targetPrefix);
      log.debug(`Url prefix restored: ${url} -> ${req.url}`);
      Reflect.deleteProperty(req, REWRITE_URL_KEY);
    }
    next();
  };
};
const viteClientMiddleware = (vite2, urlRoot, log) => {
  return (req, res, next) => {
    let shouldNext = true;
    if (req.url === `${vite2.config.base}@vite/client`) {
      let refererUrl = void 0;
      if (req.headers.referer) {
        try {
          refererUrl = new URL(req.headers.referer).pathname;
        } catch {
          log.debug(`not valid referer header`, req.headers.referer);
        }
      }
      const relativeRefererUrl = refererUrl == null ? void 0 : refererUrl.replace(urlRoot, "/");
      if (refererUrl && refererUrl.startsWith(urlRoot) && relativeRefererUrl && unwantedViteClientHtml.has(relativeRefererUrl)) {
        log.debug(
          `${relativeRefererUrl} is requesting vite client which will be mock by karma-vite because the request referer do not need hmr`
        );
        shouldNext = false;
        void vite2.transformRequest(`${VITE_FS_PREFIX.slice(0, 1)}${VITE_CLIENT_ENTRY}`).then((result) => {
          if (result) {
            res.setHeader("Content-Type", "application/javascript");
            res.end(result.code);
          } else {
            log.debug(
              `transformRequest by ${relativeRefererUrl} result get empty content`,
              result
            );
            next();
          }
        }).catch((err) => {
          log.debug(`transformRequest by ${relativeRefererUrl} error`, err);
          next();
        });
      }
    }
    shouldNext && next();
  };
};
const middlewareFactory = (vite2, config, logger) => {
  const { urlRoot } = config;
  const log = logger.create("karma-vite:middleware");
  if (vite2 === void 0) {
    log.error("The config of framework field missing vite");
    throw "The config of framework field missing vite";
  }
  const handler = connect();
  handler.use(adjustPrefixMiddleware(urlRoot, vite2.config.base, log));
  handler.use(viteClientMiddleware(vite2, urlRoot, log));
  handler.use((req, res, next) => {
    vite2.middlewares(req, res, next);
  });
  handler.use(restorePrefixMiddleware(log));
  return handler;
};
middlewareFactory.$inject = ["vite.value", "config", "logger"];
function filterBelongToViteFiles(files) {
  return files && files.filter((file) => {
    if (typeof file === "object" && file.type === "module" && file.served === false) {
      return true;
    }
  }).map((file) => file.pattern);
}
function resolveEnableIstanbulPlugin(config) {
  var _a, _b;
  const hardEnable = (_b = (_a = config.vite) == null ? void 0 : _a.coverage) == null ? void 0 : _b.enable;
  return hardEnable != null ? hardEnable : config.reporters.some((report) => report.includes("coverage"));
}
function resolveIstanbulPluginConfig(config) {
  var _a, _b;
  const coverage = ((_a = config.vite) == null ? void 0 : _a.coverage) || {};
  const { enable, ...pluginOptions } = coverage;
  return {
    cwd: (_b = coverage == null ? void 0 : coverage.cwd) != null ? _b : config.basePath,
    ...pluginOptions
  };
}
async function resolveViteConfig(inlineViteConfig, config) {
  var _a;
  let viteConfig = (_a = config.vite) == null ? void 0 : _a.config;
  if (!viteConfig)
    return inlineViteConfig;
  viteConfig = await (typeof viteConfig === "function" ? viteConfig = await viteConfig({ command: "serve", mode: "development" }) : viteConfig);
  return vite.mergeConfig(viteConfig, inlineViteConfig);
}
function rewriteViteServerRestart(server, oldestServer, log) {
  log.debug("vite server restart method was rewritten");
  server.restart = (forceOptimize) => {
    if (!server._restartPromise) {
      server._forceOptimizeOnRestart = !!forceOptimize;
      server._restartPromise = restartViteServer(server, oldestServer).finally(
        () => {
          server._restartPromise = void 0;
          server._forceOptimizeOnRestart = false;
        }
      );
    }
    return server._restartPromise;
  };
}
async function restartViteServer(server, oldestServer) {
  await server.close();
  let newServer = void 0;
  try {
    let inlineConfig = server.config.inlineConfig;
    if (server._forceOptimizeOnRestart) {
      inlineConfig = vite.mergeConfig(inlineConfig, {
        server: {
          force: true
        }
      });
    }
    newServer = await vite.createServer(inlineConfig);
  } catch (err) {
    server.config.logger.error(err.message, {
      timestamp: true
    });
    return;
  }
  for (const key in newServer) {
    if (key === "_restartPromise") {
      newServer[key] = oldestServer[key];
    } else if (key !== "app") {
      oldestServer[key] = newServer[key];
    }
  }
  server.config.logger.info("server restarted.", { timestamp: true });
  newServer._restartPromise = void 0;
  return newServer;
}
const viteServerFactory = (config, executor, logger) => {
  var _a;
  const log = logger.create("karma-vite:viteServer");
  const { basePath } = config;
  const belongToViteFiles = filterBelongToViteFiles(config.files);
  const isEnableIstanbulPlugin = resolveEnableIstanbulPlugin(config);
  const version = ((_a = config.vite) == null ? void 0 : _a.version) || getViteVersion(basePath);
  let versionViteConfig;
  if (version === "vite2") {
    versionViteConfig = {
      server: {
        middlewareMode: "ssr"
      }
    };
  } else {
    versionViteConfig = {
      server: {
        middlewareMode: true
      },
      appType: "custom"
    };
  }
  const baseViteConfig = {
    root: basePath,
    server: {
      base: "__vite__",
      watch: {
        ignored: ["**/coverage/**"]
      }
    },
    build: {
      // only intent to hidden the warning of IstanbulPlugin
      sourcemap: isEnableIstanbulPlugin || void 0
    },
    plugins: [
      isEnableIstanbulPlugin && IstanbulPlugin(resolveIstanbulPluginConfig(config))
    ],
    optimizeDeps: {
      entries: belongToViteFiles
    }
  };
  const inlineViteConfig = vite.mergeConfig(baseViteConfig, versionViteConfig);
  const viteProvider = resolveViteConfig(inlineViteConfig, config).then((config2) => {
    log.debug(`using resolved config: 
%O
`, config2);
    return vite.createServer(config2);
  }).then((vite2) => {
    viteProvider.value = vite2;
    const interceptViteSend = (server) => {
      log.debug(`vite server ws send method was intercepted`);
      const send = server.ws.send.bind(server.ws);
      server.ws.send = (payload) => {
        log.debug(
          `the wss send method of vite server was called with payload.type: `,
          payload.type
        );
        if (payload.type === "full-reload" && payload.path !== "*" || payload.type === "update" || payload.type === "prune" || payload.type === "custom") {
          executor.schedule();
        }
        send(payload);
      };
    };
    const interceptViteRestart = (server) => {
      log.debug(`vite server restart method was intercepted`);
      const restart = server.restart.bind(server);
      server.restart = async () => {
        const newServer = await restart();
        if (newServer) {
          log.debug("vite server restarted");
          rewriteViteServerRestart(
            newServer,
            vite2,
            log
          );
          interceptViteSend(newServer);
          interceptViteRestart(newServer);
          executor.schedule();
        }
        return newServer;
      };
    };
    rewriteViteServerRestart(
      vite2,
      vite2,
      log
    );
    interceptViteSend(vite2);
    interceptViteRestart(vite2);
    return vite2;
  });
  viteProvider.value = void 0;
  return viteProvider;
};
viteServerFactory.$inject = ["config", "executor", "logger"];
const index = {
  "framework:vite": ["factory", frameworkFactory],
  "middleware:vite": ["factory", middlewareFactory],
  "middleware:vite-before": ["factory", beforeMiddlewareFactory],
  vite: ["factory", viteServerFactory]
};
module.exports = index;
